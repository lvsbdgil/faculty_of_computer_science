# Импортируем модуль json для загрузки словарей из файлов
import json

# =============== ЗАГРУЗКА СЛОВАРЕЙ ===============
# Эти файлы содержат:
# - possible_numbers.json: слова и числовые значения
# - possible_operations.json: словосочетания и символы операций (+, -, *, /)

# Открываем и загружаем словарь чисел
with open("possible_numbers.json", "r", encoding="utf-8") as f:
    # json.load() преобразует содержимое JSON-файла в Python-словарь
    possible_numbers = json.load(f)

# Открываем и загружаем словарь операций
with open("possible_operations.json", "r", encoding="utf-8") as f:
    possible_operations = json.load(f)

# =============== 2. ВСПОМОГАТЕЛЬНЫЕ КОНСТАНТЫ ===============
# Слово "и" не является числом, но используется как разделитель в дробях ("пять и три десятых")
# Выделяем его отдельно, чтобы разрешить при валидации
SERVICE_WORDS = {"и"}

# Получаем список всех операций
# и сортируем его по убыванию количества слов в фразе.
# Это нужно, чтобы при поиске сначала проверялись длинные фразы ("умножить на"),
# а не короткие ("на"), иначе будет ошибка.
operation_phrases = sorted(
    possible_operations.keys(),  # берем все ключи из словаря операций
    key=lambda phrase: len(phrase.split()),  # длина фразы в словах
    reverse=True  # сначала длинные
)


# =============== ТОКЕНИЗАЦИЯ ВХОДА ===============
def tokenize_expression(tokens):
    """
    На вход получает список слов, например: ["пять", "и", "три", "десятых", "плюс", "два"]
    На выходе — список токенов вида:
        [("num", "пять"), ("num", "и"), ("num", "три"), ("num", "десятых"), ("op", "+"), ("num", "два")]

    Почему так? Потому что сначала нужно определить, где числа, а где операции.
    Особенно важно распознать многословные операции как единое целое.
    """
    i = 0  # текущая позиция в списке слов
    result = []  # сюда будем складывать токены

    # Пока не обработали все слова
    while i < len(tokens):
        matched = False  # флаг: нашли ли мы операцию на этой итерации?

        # Перебираем все операции, начиная с самых длинных
        for phrase in operation_phrases:
            # Разбиваем фразу на отдельные слова: "умножить на" → ["умножить", "на"]
            phrase_tokens = phrase.split()
            phrase_length = len(phrase_tokens)

            # Проверяем, совпадает ли срез входного списка с этой фразой
            if tokens[i:i + phrase_length] == phrase_tokens:
                # Если совпадает — добавляем операцию как токен ("op", символ)
                result.append(("op", possible_operations[phrase]))
                # Пропускаем столько слов, сколько в фразе
                i += phrase_length
                matched = True
                break  # выходим из цикла по операциям — фраза найдена

        # Если ни одна операция не совпала — значит, это часть числа
        if not matched:
            result.append(("num", tokens[i]))
            i += 1  # переходим к следующему слову

    return result


# =============== ГРУППИРОВКА ТОКЕНОВ ===============
def group_tokens(tokenized):
    """
    Преобразует токены вида:
        [("num", "пять"), ("num", "и"), ..., ("op", "+"), ("num", "два")]
    в структуру:
        [
            ["пять", "и", "три", "десятых"],  # первое число как список слов
            ("op", "+"),                       # операция
            ["два"]                            # второе число
        ]

    Это необходимо, потому что каждое "число" может состоять из нескольких слов,
    и только после группировки мы сможем преобразовать каждую группу в число.
    """
    groups = []  # итоговый список: чередуются числа и операции
    current_number = []  # временный буфер для накопления слов одного числа

    # Проходим по каждому токену
    for token_type, value in tokenized:
        if token_type == "num":
            # Слово принадлежит числу — добавляем в буфер
            current_number.append(value)
        else:  # token_type == "op"
            # Встретили операцию
            if not current_number:
                # Если буфер пуст — значит, операция идёт первой или после другой операции
                raise ValueError("Операция без предшествующего числа")
            # Сохраняем собранное число (список слов)
            groups.append(current_number)
            # Сохраняем операцию
            groups.append(("op", value))
            # Очищаем буфер для следующего числа
            current_number = []

    # После цикла может остаться последнее число (после последней операции)
    if not current_number:
        raise ValueError("Выражение заканчивается операцией")
    groups.append(current_number)

    return groups


# =============== ПРЕОБРАЗОВАНИЕ СЛОВ В ЧИСЛО ===============
def evaluate_number(words):
    """
    Преобразует список слов, описывающих одно число, в float.
    Поддерживает три случая:
      1. Точное совпадение: "двадцать пять" → 25 (если есть в словаре)
      2. Дробь: "пять и три десятых" → 5.3
      3. Составное целое: "сто двадцать три" → 100 + 20 + 3 = 123

    Важно: все слова в списке `words` уже считаются допустимыми (прошли валидацию).
    """
    # Собираем исходную фразу, чтобы проверить точное совпадение
    full_phrase = " ".join(words)
    if full_phrase in possible_numbers:
        # Пример: "двадцать пять" уже есть как ключ → возвращаем значение
        return float(possible_numbers[full_phrase])

    # Проверяем, есть ли слово "и" — признак дроби
    if "и" in words:
        # Находим позицию слова "и"
        idx = words.index("и")
        # Всё до "и" — целая часть числа
        integer_part_words = words[:idx]
        # Всё после "и" — дробная часть (должна содержать числитель и знаменатель)
        fractional_part_words = words[idx + 1:]

        # Дробная часть должна содержать как минимум 2 слова: "три десятых"
        if len(fractional_part_words) < 2:
            raise ValueError("Неполная дробная часть")

        # Числитель — все слова, кроме последнего (например: ["три"] или ["двадцать", "пять"])
        numerator_words = fractional_part_words[:-1]
        # Знаменатель — последнее слово (например: "десятых")
        denominator_word = fractional_part_words[-1]

        # Вычисляем целую часть: суммируем значения всех слов
        integer_value = sum(possible_numbers[word] for word in integer_part_words)

        # Вычисляем числитель: тоже суммируем
        numerator_value = sum(possible_numbers[word] for word in numerator_words)

        # Получаем значение знаменателя из словаря
        if denominator_word not in possible_numbers:
            # Эта ошибка может возникнуть, если валидация была отключена
            raise ValueError(f"Неизвестный знаменатель: {denominator_word}")
        denominator_value = possible_numbers[denominator_word]

        # Возвращаем результат: целая часть + числитель / знаменатель
        return integer_value + numerator_value / denominator_value

    # Если "и" нет — обрабатываем как обычное составное число (например, "сто двадцать")
    # Просто суммируем значения всех слов
    total = sum(possible_numbers[word] for word in words)
    return float(total)


# =============== ВЫЧИСЛЕНИЕ ВЫРАЖЕНИЯ ===============
def calculate(groups):
    """
    Получает список вида: [число, операция, число, операция, число, ...]
    Вычисляет результат строго слева направо (без учёта математического приоритета).

    Пример: ["два"], ("op", "*"), ["три"], ("op", "+"), ["один"]
      → сначала 2 * 3 = 6
      → затем 6 + 1 = 7
    """
    # Начинаем вычисление с первого числа
    result = evaluate_number(groups[0])
    i = 1  # начинаем с первой операции (она на позиции 1)

    # Пока есть операции и следующие числа
    while i < len(groups):
        # Извлекаем операцию (например, "+")
        operation = groups[i][1]
        # Извлекаем следующее число и преобразуем его
        next_number = evaluate_number(groups[i + 1])

        # Выполняем операцию в зависимости от символа
        if operation == "+":
            result += next_number
        elif operation == "-":
            result -= next_number
        elif operation == "*":
            result *= next_number
        elif operation == "/":
            # Проверяем деление на ноль
            if next_number == 0:
                raise ValueError("Деление на ноль")
            result /= next_number
        else:
            # На случай, если вдруг пришла неизвестная операция
            raise ValueError(f"Неизвестная операция: {operation}")

        # Переходим к следующей операции (через одно число)
        i += 2

    return result


# =============== ОСНОВНАЯ ФУНКЦИЯ ===============
def main():

    print("Текстовый калькулятор")
    print('Пример ввода: "пять и три десятых плюс два"')

    try:
        # Считываем строку от пользователя и убираем лишние пробелы по краям
        raw_input = input("\n> ").strip()

        # Если ввод пустой — выходим
        if not raw_input:
            print("Пустой ввод")
            return

        # Разбиваем строку на слова по пробелам
        tokens = raw_input.split()

        # =============== ВАЛИДАЦИЯ: проверяем, что все слова известны ===============
        # Собираем все допустимые слова:
        allowed_words = (
                set(possible_numbers.keys()) |  # все ключи из словаря чисел
                SERVICE_WORDS |  # слово "и"
                {word for phrase in operation_phrases for word in phrase.split()}  # все слова из операций
        )

        # Проверяем каждое слово из ввода
        for word in tokens:
            if word not in allowed_words:
                raise ValueError(f"Неизвестное слово: {word}")

        # =============== ПАРСИНГ И ВЫЧИСЛЕНИЕ ===============
        # Преобразуем слова в токены (числа и операции)
        tokenized = tokenize_expression(tokens)
        # Группируем токены в числа и операции
        groups = group_tokens(tokenized)
        # Вычисляем результат
        result = calculate(groups)

        # =============== ВЫВОД РЕЗУЛЬТАТА ===============
        # Если результат — целое число (например, 5.0), выводим как целое
        if result.is_integer():
            print(int(result))
        else:
            print(result)

    except Exception as e:
        # Перехватываем любую ошибку и выводим её понятно
        print(f"Ошибка: {e}")

if __name__ == "__main__":
    main()
